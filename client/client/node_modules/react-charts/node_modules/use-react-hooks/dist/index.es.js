import React from 'react';

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

var currentFiber = void 0;

// Utils
var leaseHook = function leaseHook() {
  if (!currentFiber) {
    throw new Error('You are trying to use hooks without the `useHooks()` HOC!');
  }
  var hooks = currentFiber.hooks;
  var index = currentFiber.hookIndex;
  currentFiber.hookIndex++;
  return [hooks, index, currentFiber];
};

function useHooks(fn) {
  var HookComponent = function (_React$Component) {
    inherits(HookComponent, _React$Component);

    function HookComponent() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, HookComponent);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = HookComponent.__proto__ || Object.getPrototypeOf(HookComponent)).call.apply(_ref, [this].concat(args))), _this), _this.hooks = [], _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(HookComponent, [{
      key: 'componentDidMount',
      // A home for our hooks

      // These are here to ensure effects work properly
      value: function componentDidMount() {
        this.hooks.forEach(function (hook) {
          if (hook.didMount) {
            hook.didMount();
          }
        });
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate() {
        this.hooks.forEach(function (hook) {
          if (hook.didUpdate) {
            hook.didUpdate();
          }
        });
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        this.hooks.forEach(function (hook) {
          if (hook.willUnmount) {
            hook.willUnmount();
          }
        });
        this.hooks = undefined;
      }
    }, {
      key: 'render',
      value: function render() {
        var _props = this.props,
            innerRef = _props.innerRef,
            rest = objectWithoutProperties(_props, ['innerRef']);
        // Every render, we need to update the
        // currentFiber to the class's instance
        // and reset the instance's hookIndex

        currentFiber = this;
        this.hookIndex = 0;
        var res = fn(rest, innerRef);
        currentFiber = null;
        return res;
      }
    }]);
    return HookComponent;
  }(React.Component);

  HookComponent.displayName = fn.displayName || fn.name;

  function HookWrapper(props, ref) {
    return React.createElement(HookComponent, _extends({}, props, { innerRef: ref }));
  }
  Object.keys(fn).forEach(function (key) {
    HookWrapper[key] = fn[key];
  });
  return HookWrapper;
}

function useRef(initialValue) {
  var _leaseHook = leaseHook(),
      _leaseHook2 = slicedToArray(_leaseHook, 2),
      hooks = _leaseHook2[0],
      hookID = _leaseHook2[1];

  if (!hooks[hookID]) {
    hooks[hookID] = {
      current: initialValue
    };
  }
  return hooks[hookID];
}

function useReducer(reducer, initialState) {
  var _leaseHook3 = leaseHook(),
      _leaseHook4 = slicedToArray(_leaseHook3, 3),
      hooks = _leaseHook4[0],
      hookID = _leaseHook4[1],
      instance = _leaseHook4[2];

  if (!hooks[hookID]) {
    hooks[hookID] = {
      state: initialState,
      dispatch: function dispatch(action) {
        hooks[hookID].state = reducer(hooks[hookID].state, action);
        instance.forceUpdate();
      }
    };
  }
  return [hooks[hookID].state, hooks[hookID].dispatch];
}

function useState(initialState) {
  return useReducer(function (state, action) {
    return typeof action === 'function' ? action(state) : action;
  }, initialState);
}

function useContext(context) {
  var _leaseHook5 = leaseHook(),
      _leaseHook6 = slicedToArray(_leaseHook5, 3),
      hooks = _leaseHook6[0],
      hookID = _leaseHook6[1],
      instance = _leaseHook6[2];

  if (!hooks[hookID]) {
    hooks[hookID] = context;
    var originalRender = instance.render.bind(instance);
    instance.render = function () {
      return React.createElement(
        context.Consumer,
        null,
        originalRender
      );
    };
  }
  return context._currentValue;
}

function usePrevious(value, watchItems) {
  var _leaseHook7 = leaseHook(),
      _leaseHook8 = slicedToArray(_leaseHook7, 2),
      hooks = _leaseHook8[0],
      hookID = _leaseHook8[1];

  if (!hooks[hookID]) {
    hooks[hookID] = {};
  }
  useEffect(function () {
    hooks[hookID].previous = value;
  }, watchItems);
  return hooks[hookID].previous;
}

function useMemo(memo, watchItems) {
  var _leaseHook9 = leaseHook(),
      _leaseHook10 = slicedToArray(_leaseHook9, 2),
      hooks = _leaseHook10[0],
      hookID = _leaseHook10[1];

  if (!hooks[hookID]) {
    hooks[hookID] = {
      watchItems: null,
      computed: null
    };
  }
  var needsUpdate = hasChanged(hooks[hookID].watchItems, watchItems);
  if (needsUpdate) {
    hooks[hookID].watchItems = watchItems;
    hooks[hookID].computed = memo();
  }
  return hooks[hookID].computed;
}

function useCallback(callback, watchItems) {
  return useMemo(function () {
    return callback;
  }, watchItems);
}

function useEffect(effect, watchItems) {
  var _leaseHook11 = leaseHook(),
      _leaseHook12 = slicedToArray(_leaseHook11, 2),
      hooks = _leaseHook12[0],
      hookID = _leaseHook12[1];

  if (!hooks[hookID]) {
    hooks[hookID] = {
      changed: false,
      watchItems: null,
      unwinder: null,
      effect: null,
      didMount: function didMount() {
        hooks[hookID].unwind = hooks[hookID].effect();
      },
      didUpdate: function didUpdate() {
        if (hooks[hookID].changed) {
          if (hooks[hookID].unwind) {
            hooks[hookID].unwind();
          }
          hooks[hookID].unwind = hooks[hookID].effect();
        }
      },
      willUnmount: function willUnmount() {
        if (hooks[hookID].unwind) {
          hooks[hookID].unwind();
        }
      }
    };
  }

  hooks[hookID].effect = effect;
  hooks[hookID].changed = false;

  var changed = hasChanged(hooks[hookID].watchItems, watchItems);
  if (changed) {
    hooks[hookID].changed = true;
    hooks[hookID].watchItems = watchItems;
  }
}

function useImperativeMethods(ref, createFn, watchItems) {
  watchItems = watchItems ? watchItems.concat([ref]) : [ref, createFn];

  useEffect(function () {
    if (typeof ref === 'function') {
      var methodsInstance = createFn();
      ref(methodsInstance);
      return function () {
        return ref(null);
      };
    } else if (ref !== null && ref !== undefined) {
      var _methodsInstance = createFn();
      ref.current = _methodsInstance;
      return function () {
        ref.current = null;
      };
    }
  }, watchItems);
}

var useMutationEffect = useEffect;
var useLayoutEffect = useEffect;

// Utils

function hasChanged(prev, next) {
  var needsUpdate = !prev;
  if (!needsUpdate && prev.length !== next.length) {
    needsUpdate = true;
  } else if (!needsUpdate && prev.some(function (item, index) {
    return item !== next[index];
  })) {
    needsUpdate = true;
  }
  return needsUpdate;
}

export { useHooks, useRef, useReducer, useState, useContext, usePrevious, useMemo, useCallback, useEffect, useImperativeMethods, useMutationEffect, useLayoutEffect };
//# sourceMappingURL=index.es.js.map
